# step1

- 部分文字列の全探索で辞書の中の要素と一致すれば、その部分をクリアとして判定する
- `s[left:right]`を動かしていき、部分文字列が一致するかを判定する
- 最後の仕切りの部分で分割可能だったならばそれは全体が分割できているので、`True`を返すようにする
- `s`の間に仕切りを空想する。それをイメージした配列に対して、その場所で分割可能かを判定する。この仕切りの配列を`dp`とした
- 上記の配列の導入で動的計画法に考えをシフト
- 実際にやってみると、`s[left:right]`の左端を固定していると、分割方法が複数あったり、辞書内で互いに部分文字列の関係がある場合に対応できないことがわかった
- `s[left:right]`の右端を固定して左端を動かすことで複数の分割方法の重ね合わせが得られるので、上記の問題をパスできるとわかったのでそのやり方に変更

# step2
- 探索する部分文字列の左端と右端のインデックスの名前を明示的に`end_i`, `start_i`とした
- DPテーブルは最後に答え判定の役割も担っているので、`dp`の名前を`can_break`とした。メモの機能は動作とコメントからも伝わるので、`dp`という名前は不要だと考えた
- コードから仕切りの概念を読み取るのが困難なので`partition_nums`で表現
- 部分文字列部分を`s[start_i:end_i]`と直接書いていたがsubstringという名前をつけた

# step3
- leetcodeで何も見ずに書き起こすのを行なった
